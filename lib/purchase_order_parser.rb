module PurchaseOrderParser
  class Parser
    attr_reader :order_number

    def initialize file_path
      @file   = File.open file_path, 'rb'
      @reader = PDF::Reader.new @file
      @number_pattern = /([a-z]+-[a-z]+-\d+-\d+?)/i
      @date_pattern   = /\d{2}\/\d{2}\/\d{4}/i
      # PO Numbers are not necessarily unique across the state; they are
      # unique within a department, however, so we need both to
      # uniquely identify a PO with the real world.
      @department_pattern = //

      # If text array is empty, we need to try OCR.
      #if text.empty?

      #end
    end

    # TODO move this method/ivar to ctor?
    # NB Text is the 'raw' lines, only split on newlines.
    def text
      @text ||= @reader.pages.map! do |page|
        page.text
      end.flatten.map! do |line|
        line.split /\n+/
      end.flatten
    end

    # TODO delete??
    def lines_info
      @lines_info ||= text.map.with_index do |t, i|
        { index:  i,
          line:   t,
          length: t.length
        } 
      end
    end

    # Group lines by the count of their entries; that is, the length of each line's array, after splitting on extraneous whitespace.
    def lines_groups
      @lines_groups = []
      #current_split = ''
      split_count = 0

      #@lines_groups ||= text.collect.with_index do |line, i|
      text.each do |line|
        split_line = line.split( /\s{2,}/ ).reject! {|e| e == '' }
        $stderr.puts "SPLIT LINE: #{split_line}"
        # If we're looking at at least one blank area, we need to start a new group.
        if split_line.nil? || split_count == 0
          split_count += 1
          @lines_groups << []
          # Guard against possibly first line being nil.
          @lines_groups.last << split_line unless split_line.nil?
        elsif !split_line.nil? && split_count > 0
          @lines_groups.last << split_line.flatten #.map {|e| e.squish }
          #unless split_line.nil?
          #{
          #  index:     i, 
          #  line:      split_line, 
          #  line_size: split_line.length
          #}
        else
        end
      end
      @lines_groups.flatten
    end

    # Each line should be an array of strigs, where the multiple spaces have been split on.
    # TODO REMOVE THIS METHOD???
    def lines
      @lines ||= text.map do |line|
        line.split /\s{2}/
      end.flatten.reject!{|l| l == '' }
      #puts "LINES? #{@lines}"
      @lines
    end

    # Basically a shortcut to the hash ?? generated by lines.
    # TODO add cateogrization for order number labels.
    def number
      @order_number ||= text.select do |line|
        line =~ /order no/i
      end.map do |line|
        line[@number_pattern]
      end.uniq.first
    end

    # TODO add classification for different dates required
    def dates
      @dates ||= text.select do |line|
        line =~ @date_pattern  
      end.map do |line|
        line[@date_pattern]
      end.uniq.first
    end
  end
end
